from fastapi import FastAPI, Body, Path, Query, HTTPExceptionfrom typing import Optionalfrom pydantic import BaseModel, Fieldfrom starlette import statusapp = FastAPI()class Course:    id: int    title: str    instructor: str    rating: int    published_year: int    def __init__(self, id: int, title: str, instructor: str, rating: int, published_year: int):        self.id = id        self.title = title        self.instructor = instructor        self.rating = rating        self.published_year = published_yearclass CourseRequest(BaseModel):    id: Optional[int] = Field(description="The id of the course.", default=None)    title: str = Field(description="The title of the course.", min_length=1, max_length=100)    instructor: str = Field(description="The instructor of the course.", min_length=3)    rating: int = Field(description="The rating of the course.", ge=0, le=100)    published_year: int = Field(description="The published year of the course.", ge=1900, le=2200)    model_config = {        "json_schema_extra": {            "example": {                "title": "The title of the course",                "instructor": "The instructor of the course",                "rating": "The rating of the course",                "published_year": "The published year of the course"            }        }    }courses_db = [    Course(1, "Python", "Atil", 5, 2034),    Course(2, "Java", "Ali", 4, 2029),    Course(3, "R", "Beyza", 4, 2028),    Course(4, "C#", "Ahmet", 5, 2045),    Course(5, "JavaScript", "Atil", 1, 2036),    Course(6, "Swift", "Zeynep", 2, 2025),]@app.get("/courses", status_code=status.HTTP_200_OK)async def get_courses():    return courses_db@app.get("/courses/{id}", status_code=status.HTTP_200_OK)async def get_course(id: int = Path(..., gt=0)):    for course in courses_db:        if course.id == id:            return course    raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Course not found")@app.get("/courses/", status_code=status.HTTP_200_OK)async def get_courses_by_rating(rating: int = Query(gt=0, le=5)):    courses_to_return = []    for course in courses_db:        if course.rating == rating:            courses_to_return.append(course)    return courses_to_return@app.post("/create-course", status_code=status.HTTP_201_CREATED)async def create_course(request: CourseRequest):    new_course = Course(**request.model_dump())    courses_db.append(assign_course_id(new_course))def assign_course_id(course: Course):    course.id = 1 if len(courses_db) == 0 else courses_db[-1].id + 1    return course@app.put("/courses/update_course", status_code=status.HTTP_200_OK)async def update_course(request: CourseRequest):    course_updated = False    for i in range(len(courses_db)):        if courses_db[i].id == request.id:            courses_db[i] = request            course_updated = True        if not course_updated:            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Course not found")@app.delete("/courses/delete/{course_id}", status_code=status.HTTP_204_NO_CONTENT)async def delete_course(course_id: int = Path(gt=0)):    course_deleted = False    for i in range(len(courses_db)):        if courses_db[i].id == course_id:            courses_db.pop(i)            course_deleted = True            break    if not course_deleted:        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Course not found")